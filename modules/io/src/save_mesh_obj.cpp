/*
 * Copyright 2022 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */
#include <lagrange/io/save_mesh_obj.h>

#include <lagrange/Attribute.h>
#include <lagrange/Logger.h>
#include <lagrange/SurfaceMeshTypes.h>
#include <lagrange/foreach_attribute.h>
#include <lagrange/utils/assert.h>

// clang-format off
#include <lagrange/utils/warnoff.h>
#include <spdlog/fmt/ostr.h>
#include <lagrange/utils/warnon.h>
// clang-format on

namespace lagrange {
namespace io {

template <typename Scalar, typename Index>
void save_mesh_obj(
    std::ostream& output_stream,
    const SurfaceMesh<Scalar, Index>& mesh,
    const SaveOptions& options)
{
    la_runtime_assert(output_stream, "Invalid output stream");

    const Index dim = mesh.get_dimension();
    la_runtime_assert(dim == 2 || dim == 3, "Mesh dimension should be 2 or 3");

    // Write header
    // TODO: Write mtl/material_id?
    const Index num_vertices = mesh.get_num_vertices();
    const Index num_facets = mesh.get_num_facets();
    fmt::print(
        output_stream,
        R"(####
#
# OBJ File Generated by Lagrange
#
####
#
# Vertices: {}
# Faces: {}
#
####
)",
        num_vertices,
        num_facets);

    // TODO: Could we refactor all 3 write_xxx into a single function?
    // TODO: How to pass material names and save this information with the mesh?

    // Write positions
    for (Index v = 0; v < num_vertices; ++v) {
        auto p = mesh.get_position(v);
        fmt::print(output_stream, "v {} {} {}\n", p[0], p[1], dim == 2 ? Scalar(0) : p[2]);
    }

    // Write normals and texcoords
    std::string found_uv_name;
    std::string found_nrm_name;
    const Attribute<Index>* uv_indices = nullptr;
    const Attribute<Index>* nrm_indices = nullptr;
    seq_foreach_named_attribute_read(mesh, [&](std::string_view name, auto&& attr) {
        using AttributeType = std::decay_t<decltype(attr)>;

        // TODO: change this for the attribute visitor that takes id and simplify this block.
        if (options.output_attributes == SaveOptions::OutputAttributes::SelectedOnly) {
            AttributeId id = mesh.get_attribute_id(name);
            if (std::find(
                    options.selected_attributes.begin(),
                    options.selected_attributes.end(),
                    id) == options.selected_attributes.end()) {
                return;
            }
        }

        if (attr.get_usage() == AttributeUsage::UV) {
            if (!found_uv_name.empty()) {
                logger().warn(
                    "Found multiple UV attributes. Only '{}' was written to disk",
                    found_uv_name);
                return;
            } else {
                found_uv_name = name;
            }

            const Attribute<typename AttributeType::ValueType>* values = nullptr;
            if constexpr (AttributeType::IsIndexed) {
                values = &attr.values();
                uv_indices = &attr.indices();
            } else {
                values = &attr;
                uv_indices = &mesh.get_corner_to_vertex();
            }
            la_runtime_assert(attr.get_num_channels() == 2);
            for (Index vt = 0; vt < values->get_num_elements(); ++vt) {
                auto p = values->get_row(vt);
                fmt::print(output_stream, "vt {} {}\n", p[0], p[1]);
            }
        }

        if (attr.get_usage() == AttributeUsage::Normal) {
            if (!found_nrm_name.empty()) {
                logger().warn(
                    "Found multiple Normal attributes. Only '{}' was written to disk",
                    found_nrm_name);
                return;
            } else {
                found_nrm_name = name;
            }

            const Attribute<typename AttributeType::ValueType>* values = nullptr;
            if constexpr (AttributeType::IsIndexed) {
                values = &attr.values();
                nrm_indices = &attr.indices();
            } else {
                values = &attr;
                nrm_indices = &mesh.get_corner_to_vertex();
            }
            la_runtime_assert(attr.get_num_channels() == 3);
            for (Index vn = 0; vn < values->get_num_elements(); ++vn) {
                auto p = values->get_row(vn);
                fmt::print(output_stream, "vn {} {} {}\n", p[0], p[1], p[2]);
            }
        }
    });

    // Write facets
    for (Index f = 0; f < num_facets; ++f) {
        const Index first_corner = mesh.get_facet_corner_begin(f);
        const auto vtx_indices = mesh.get_facet_vertices(f);
        la_runtime_assert(
            vtx_indices.size() >= 3,
            fmt::format("Mesh facet {} should have >= 3 vertices", f));
        output_stream << "f";
        for (Index lv = 0; lv < vtx_indices.size(); ++lv) {
            // vertex_index/texture_index/normal_index
            Index v = vtx_indices[lv] + 1;
            Index vt = (uv_indices ? uv_indices->get(first_corner + lv) : 0) + 1;
            Index vn = (nrm_indices ? nrm_indices->get(first_corner + lv) : 0) + 1;
            if (!uv_indices && !nrm_indices) {
                fmt::print(output_stream, " {}", v);
            } else if (uv_indices && !nrm_indices) {
                fmt::print(output_stream, " {}/{}", v, vt);
            } else if (uv_indices && nrm_indices) {
                fmt::print(output_stream, " {}/{}/{}", v, vt, vn);
            } else if (!uv_indices && nrm_indices) {
                fmt::print(output_stream, " {}//{}", v, vn);
            }
        }
        output_stream << "\n";
    }

    // TODO: Write edges
}

template <typename Scalar, typename Index>
void save_mesh_obj(
    const fs::path& filename,
    const SurfaceMesh<Scalar, Index>& mesh,
    const SaveOptions& options)
{
    fs::ofstream output_stream(filename);
    save_mesh_obj(output_stream, mesh, options);
}

#define LA_X_save_mesh(_, Scalar, Index)        \
    template void save_mesh_obj(                \
        std::ostream& output_stream,            \
        const SurfaceMesh<Scalar, Index>& mesh, \
        const SaveOptions& options);            \
    template void save_mesh_obj(                \
        const fs::path& filename,               \
        const SurfaceMesh<Scalar, Index>& mesh, \
        const SaveOptions& options);
LA_SURFACE_MESH_X(save_mesh, 0)

} // namespace io
} // namespace lagrange
